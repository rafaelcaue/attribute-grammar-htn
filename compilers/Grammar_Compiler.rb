module Grammar_Compiler
  extend self

  SPACER = '-' * 30
  
  #-----------------------------------------------
  # Predicates to grammar
  #-----------------------------------------------

  def preconditions_to_grammar(output, group, group_not = [])
    if group.empty? and group_not.empty?
    else
      output << "before("
      group.each {|pre| output << "(#{pre.join(' ')}) "}
      group_not.each {|pre| output << "(not (#{pre.join(' ')})) "}
      output << ")\n"
    end
  end
  
  #-----------------------------------------------
  # Goals to grammar
  #-----------------------------------------------

  def goals_to_grammar(output, group)
    if group.empty?
    else
      group.each {|pre|
        name = pre.name.capitalize
        if pre.equal?(group.last)
          output << "#{name}(#{pre.args.join(', ')}) ["
        else
          output << "#{name}(#{pre.args.join(', ')})."
        end
      }
      output << "\n"
    end
  end  
  
  #-----------------------------------------------
  # States to grammar
  #-----------------------------------------------

  def states_to_grammar(output, group)
    if group.empty?
    else
      group.each {|pre| output << "  (#{pre.name} #{pre.args.join(' ')})\n"}
    end
  end  
  
  #-----------------------------------------------
  # Delete effects to grammar
  #-----------------------------------------------

  def del_eff_to_grammar(output, group)
    if group.empty?
    else
      output << "after_minus("
      group.each {|pre| output << "(#{pre.join(' ')}) "}
      output << ")\n"
    end
  end
  
  #-----------------------------------------------
  # Add effects to grammar
  #-----------------------------------------------

  def add_eff_to_grammar(output, group)
    if group.empty?
    else
      output << "after_plus("
      group.each {|pre| output << "(#{pre.join(' ')}) "}
      output << ")\n"
    end
  end
  
  #-----------------------------------------------
  # Subtasks to grammar
  #-----------------------------------------------

  def subtasks_to_grammar(output, group)
    if group.empty?
      output << "lambda [\n"
    else
      group.each {|pre|
        name = pre.first.capitalize
        if pre.equal?(group.last)
          output << "#{name}(#{pre[1..-1].join(', ')}) ["
        else
          output << "#{name}(#{pre[1..-1].join(', ')})."
        end
      }
      output << "\n"
    end
  end

  #-----------------------------------------------
  # Compile domain
  #-----------------------------------------------

  def compile_domain(domain_name, problem_name, operators, methods, predicates, state, tasks)
    domain_str = "; Generated by Hype\n\n"
    domain_str << "----------------OPERATORS-------------------------------------------------------\n"
    # Operators
    operators.each {|op|
      # Header
      domain_str << "\n!#{op.name.capitalize}(#{op.args.join(', ')}) -> #{op.name}_(#{op.args.join(', ')}) [\n"
      # Preconditions
      preconditions_to_grammar(domain_str, op.positive_precond, op.negative_precond)
      # Delete effects
      del_eff_to_grammar(domain_str, op.negative_effect)
      # Add effects
      add_eff_to_grammar(domain_str, op.positive_effect)
      domain_str << "]"
    }
    # Methods
    domain_str << "\n\n----------------METHODS---------------------------------------------------------\n"
    methods.each {|met|
      # Header
      domain_str << "\n#{met.task_name.capitalize}(#{met.variables.join(', ')}) -> "
      # Substasks
      subtasks_to_grammar(domain_str, met.subtasks)
      # Preconditions
      preconditions_to_grammar(domain_str, met.positive_precond, met.negative_precond)
      domain_str << "]\n"
    }
    domain_str << "\n"
  end

  #-----------------------------------------------
  # Compile problem
  #-----------------------------------------------

  def compile_problem(domain_name, problem_name, operators, methods, predicates, state, tasks, domain_filename)
    problem_str = "; Generated by Hype\n\n"
	# Goals
	problem_str << "\nS0 -> "
	goals_to_grammar(problem_str, tasks)
	# States
	problem_str << "after_plus((\n"
	states_to_grammar(problem_str,state)
	problem_str << "))"
	problem_str << "\n]" 
  end
end
